（以下描述均假设不会出现一个new出来的指针作为多个shared_ptr类实例化对象的构造参数这种情况，也就是说new一个待管理内存后立即将结果传递到智能指针中；假设不使用make_shared函数创建智能指针，都是把new的结果传入进行构造的）
* 源码阅读（阅读shared_ptr和weak_ptr的源码，P.J. Plauger编写的版本,visual studio2015 shared_ptr转到定义）
	* shared_ptr
		* 类的组织结构
			* shared_ptr类继承了_Ptr_base类
			* _Ref_count类继承了_Ref_count_base类
		* 各类的数据成员
			* _Ptr_base类的数据成员有_Ty *_Ptr和_Ref_count_base *_Rep
			* _Ref_count_base的数据成员有_Atomic_counter_t _Uses和_Atomic_counter_t _Weaks，_Ref_count的数据成员有_Ty * _Ptr
			* 可以发现_Ptr_base类的数据成员中和_Ref_count类的数据成员中均有_Ty * _Ptr，前者是为了用户程序在使用智能指针时解引用的方便，后者是为了智能指针自身管理裸指针指向的内存的方便。
		* shared_ptr解析
			* shared_ptr的核心是对两部分内存进行操作，一部分内存是裸指针_Ty *_Ptr指向的内存，另一部分内存是_Ref_count_base *_Rep指向的控制块内存（该块内存是在构造一个全新的shared_ptr时new _Ref_count得到的）。控制块_Ref_count起到对裸指针指向的内存的管理以及对其自身内存的管理的作用。指针_Ptr和指针_Rep是_Ptr_base类的数据成员，而_Ptr_base类是shared_ptr类的基类，这在上边已有提及。
			* 通过指针_Rep可以访问和修改控制块中的强引用计数_Uses和弱引用计数_Weaks的值，根据这两个值可对裸指针指向的内存空间和控制块自身进行内存管理：当_Uses为0时delete _Ptr，当_Uses为0且_Weaks为0时delete _Rep。_Uses的值在shared_ptr进行拷贝构造操作时++，拷贝赋值操作时因被赋值和赋值对象的不同而对各自控制块内的_Uses--或++，移动操作时不变，shared_ptr对象析构时--；_Weaks的值初始时为1，当有weak_ptr绑定到shared_ptr操作出现时_Weaks++，weak_ptr对象析构时_Weaks--，所有指向同一内存的shared_ptr对象都析构导致_Uses为0时在_Ref_count_base::_Decref()函数中会_Weaks--。
			* 值得一提的是，虽然_Rep指向的控制块内存_Ref_count是由shared_ptr最开始在构造时new出来的，但一旦在shared_ptr全部销毁之前出现过weak_ptr绑定到shared_ptr这样的操作，weak_ptr就指向了该控制块，这样的话即便shared_ptr都被销毁，weak_ptr也能管理控制块内存_Ref_count。
			* 根据上述分析，裸指针指向的内存和控制块内存的生命周期是不同步的，主要是由于“在控制块内，当_Uses为0时delete _Ptr，当_Uses为0且_Weaks为0时delete _Rep”这个机制：可能存在下述情况，在有几个shared_ptr管理同一块内存的情况下，用户程序定义了几个weak_ptr绑定到shared_ptr上，导致控制块中_Weaks值的增加，当出现所有shared_ptr都销毁而定义的几个weak_ptr仍然没有被销毁的情况时，_Uses为0，裸指针指向的内存被delete，而_Weaks的值由于weak_ptr没有全部被销毁还没有降到1，相应的控制块内存仍然存在（未被delete），直到所有weak_ptr都销毁才delete控制块内存。
	* weak_ptr
		* 类的组织结构
			* weak_ptr类继承了_Ptr_base类
		* weak_ptr解析
			* weak_ptr是附属于shared_ptr的一个智能指针，其不能单独管理一个裸指针，因此其构造函数的参数类型要么是weak_ptr，要么就是shared_ptr，且在拷贝移动操作过程中，只改变控制块中_Weaks的值，不改变_Uses的值。具体如何与shared_ptr交互，在上边对shared_ptr的解析中已有描述。
* 对已有代码的改进思考
	* weak_ptr的引入可以解决单独shared_ptr可能存在的循环引用造成内存泄漏的问题。因此，在实现shared_ptr的代码中，是必须引入弱引用计数_Weaks的。当然强引用计数_Uses更是实现基本功能必不可少的东西。我现在的shared_ptr代码中并没有引入弱引用计数_Weaks变量，也没有对weak_ptr的支持，因此无法解决实际应用中可能出现的循环引用问题。
	* 正如我在源码解析中所述：标准实现的shared_ptr中，裸指针指向的内存和控制块内存生命周期是不同步的，主要是由于weak_ptr的延迟销毁会延迟控制块内存的delete时机。这样的不同步为借助weak_ptr解决一些问题提供了可能。而在我自己的shared_ptr实现中，裸指针指向的内存和控制块内存生命周期完全同步，也就是管理的裸指针指向的内存、强引用计数指针指向的内存、互斥锁指针指向的内存同时new又同时delete。
	* 标准实现的shared_ptr中，是明确有两个指针的，一个是指向被管理内存的裸指针，另一个是指向控制块内存的指针，这样人为的把裸指针指向的内存和控制块内存独立开来，只需要考虑管理两块内存即可。而我的实现中，虽然逻辑上仍然是管理两部分内存（一部分代表裸指针指向的被管理内存，另一部分代表控制块内存），但是实际在代码实现上我管理了三块内存，包括裸指针指向的内存、强引用计数指针指向的内存、互斥锁指针指向的内存，每次构造和销毁时我都需要同时进行三次new和delete操作；尤其是如果再考虑到今后要把弱引用计数加进去，我又要在构造和销毁时多一次new和delete操作，还可能加入删除器、分配器等控制成员；这样做没有充分利用封装的编程思想，各模块耦合严重，编程的心智负担严重；没有利用C++提供的继承和多态特性，没有把一些基本的模块抽象出来（比如shared_ptr和weak_ptr的公有接口），造成了程序可拓展性差的问题，且在设计上根本没有为weak_ptr留出接口；以上种种，都可以像标准实现的那样通过定义一个控制块类得以解决。 
	* 标准实现的shared_ptr中，_Uses和_Weaks都是_Atomic_counter_t类型的，递归的查看定义，发现其本质上是一个unsigned long类型，且通过_MT_INCR()、_MT_DECR()这样的宏定义完成了对_Uses和_Weaks变量的原子操作，性能较好。在这一点上，我的代码需要借助互斥锁保证操作的原子性，每次在shared_ptr对象的构造赋值移动过程中都要花费互斥锁指针复制的时间开销以及对应指针的内存占用，且在每次对强引用计数操作时都需要有固定的三条语句（加锁、操作、解锁），性能较差。
	* 我的现有代码封装性不好，比如每次对强引用计数++或者--时，都是固定的三条语句（加锁、操作、解锁），且紧随其后会有一个if语句根据强引用计数是否为0来决定是否delete三个被管理内存，这样的代码段重复出现了两次，这样的话代码非常冗余，完全可以像标准实现中的那样封装_Decref()、_Incref()基本操作函数对强引用变量原子的进行操作以及判断是否需要delete被管理的内存。
	* 我的现有代码虽然做到了对强引用计数指针指向的内存的操作的线程安全，但是对于数据成员中的三个指针本身的读写操作并没有做到线程安全。可能会出现存在于.data段的智能指针对象被多个线程读或写造成智能指针管理的裸指针指向的内存与控制块的不匹配。这种情况可以在用户程序应用智能指针时加锁予以避免。
	* 在标准实现中，赋值运算符的实现是采用拷贝并交换的技术，先构造一个临时的shared_ptr对象，然后再与*this进行swap操作，这样自动处理了自赋值情况且在整个赋值过程中相当于直接调用了shared_ptr的构造函数和析构函数对控制块中的引用计数进行了更新。而我的代码不光需要手动处理自赋值的情况，还需要手动对强引用计数进行更新，手动判断是否需要delete内存，完全没有调用到现成的构造函数和析构函数，写出的代码是比较冗余的。
	
			
	