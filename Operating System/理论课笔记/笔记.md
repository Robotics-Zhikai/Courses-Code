1、内核中的具体实现有这样特殊的权限，这样就能修改敏感的和被保护的硬件资源，比如访问硬件磁盘。
2、希望给程序员完全的自由，但是实际上又不能是真正的完全自由 
3、三对矛盾 高效-易用 简单的API-强大的功能 灵活性-安全性
4、操作系统API有可能会有交互 比如open返回一个fd，紧接着进行fork的话在fork出的子进程中仍然能够访问对应的fd
5、随着硬件的逐步提升，计算机所使用的硬件在变化，网速也在指数级的增长，所有的这些都需要时不时的重新思考，操作系统是如何被设计的。
6、喜欢基础架构，比如喜欢构建一些其他程序可以用的服务，那么这门课程都是有关基础架构的内容
7、如果曾花费了大量时间来定位应用程序的bug，或者定位安全的问题，那么最终都要归结于理解操作系统是如何运作的。就是说当应用程序运行出错时，需要操作系统去收拾残局
如果用了Python，在某种程度上就能与系统调用接口隔离了；高级语言由于要兼顾移植性，所以不能依赖于特定的系统调用。
最后的分数主要是由lab决定的。 百分之90的分数都是lab。注重软件实操的课程
8、会在第一个lab中使用这里介绍的系统调用，并在后续的lab中扩展并提升这些系统调用的内部实现。
9、xv6是一个简化的类Unix系统，Unix系统是Linux和osx系统的基础。受Unix启发，足够简单，可以在几周内很直观的读完所有的代码
xv6运行在一个risv-v微处理器上。理论上可以在一个risc-v计算机上运行xv6，但是我们会在qemu模拟器上运行xv6
10、许多的unix操作系统都会从文件描述符0读取数据，然后向文件描述符1写入数据

1.6 open系统调用
11、最直接的创建文件描述符的方法是open系统调用
12、字节流就是一段连续的数据按照字节的长度读取
13、文件描述符本质上对应了内核中的一个表单数据，内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的key是文件描述符。每个进程都有“独立”的文件描述符空间。不同进程中相同数字的文件描述符可能会对应到不同的文件。高级语言如Python中的open最终会归结到系统调用open中。

1.7 Shell


1.8 fork系统调用
1、即使两个子进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。
2、文件描述符的表单值也从父进程拷贝到子进程，





















