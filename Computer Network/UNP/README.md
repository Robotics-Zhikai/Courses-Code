# UNP
## 第二章 传输层：TCP、UDP和SCTP
* 某个应用进程写数据到一个TCP套接字中发生的步骤
	* 当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据（或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据），该应用进程将被投入睡眠。这里假设套接字是阻塞的，是通常的默认设置。内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区。因此，从写一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，**并不表示对端的TCP或应用进程已接受到数据**
	*  ![图2-15](./image/图2-15.png)
	*  这一端的TCP提取**套接字发送缓冲区**中的数据并把它发送给对端TCP，其过程基于TCP数据传送的所有规则。对端TCP必须确认收到的数据，伴随来自对端的ACK的不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到他被对端确认为止。（可参考CS144中sender的实现：发送缓冲区可看做Bytestream，通过read Bytestream发送TCPsegment，并把未确认的TCPsegment保存到一队列中，直到对端发来ACK确认就把相应的TCPsegment副本丢弃。值得一提的是，read Bytestream这一动作就使得Bytestream空出来了空间，也就是使得套接字发送缓冲区空出来了空间，能够被应用进程write继续写入）
## 第三章 套接字编程简介
* 字节流套接字上的read和write函数所表现的行为不同于通常的文件I/O。字节流套接字上调用read或write输入或输出的字节数可能比请求的数量少，然而这不是出错的状态。这个现象的原因在于内核中用于套接字的缓冲区可能已到达了极限。**值不足的现象在read一个字节流套接字时很常见，但是在write一个字节流套接字时只能在该套接字为非阻塞的前提下才出现**
* write到内核缓冲区的数据不一定全部都发到对端了，实际上就是CS144中所讲的write到Bytestream，然后按照TCP协议去发。read的话就是read Bytestream，Bytestream是TCP协议交付数据存放的地点，可以把Bytestream 当成内核缓冲区（见[本笔记这里](#第二章)）。

## 第四章 基本TCP套接字编程
* close一个TCP套接字后，该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的第一个参数。

## 第五章 TCP客户/服务器程序示例
* 探讨许多边界条件：客户和服务器启动时发生什么？客户正常终止时发生什么？服务器进程在客户之前终止？等等
* 单独接收到FIN将导致read函数返回0
* connect发起三次握手
* listen创建一监听套接字
* accept一直阻塞到监听套接字established队列有fd才返回
* ![TCP连接状态](./image/TCP连接状态.png)
* 被动收到FIN才有CLOSE_WAIT状态
* 子进程终止时，会给父进程发送一个SIGCHLD信号
* 信号处理函数可以中断慢速系统调用，并通过设置看是重启还是使系统调用退出。退出后会设置errno=EINTR错误
* 当一个进程向某个已收到RST的套接字执行写操作时，内核向该进程发送一个SIGPIPE信号。写一个已接收FIN的套接字不成问题，但是写一个已接收RST的套接字则是一个错误.
* Unix系统关机时，init进程通常先给所有进程发送SIGTERM信号，等待一段时间（让SIGTERM的信号处理函数进行清除和终止工作），然后给所有仍在运行的进程发送SIGKILL信号
* 总结来看，套接字的引用计数为0时，发送FIN给对端，对端TCP连接读半关闭，对端若阻塞在read，则退出阻塞，返回0；对端若在接收到FIN的socket进行write（这是允许的，且能够给对方发送过去），那么会收到对方发来的RST（若对方已经退出进程），再写RST就会brokenpipe，brokenpipe后会由write设置errno为EPIPE；收到RST若正处于read阻塞，则调用返回errno=ECONNRESET错误；如果正在进行系统调用，然后被信号处理函数中断而没有重启系统调用，则会设置errno=EINTR；
* 服务器与客户端如果大端小端不一致，那么在传递数值数据时会失常，除非事先告知对方的大小端，以便能在解析数据时提前知道。

## 第六章 I/O复用：select和poll函数
* 同步I/O操作：导致请求进程阻塞，直到I/O操作完成
* 异步I/O操作：不导致请求进程阻塞
* ![五种I/O模型的比较](./image/五种IO模型的比较.png)
* select被中断也会返回errno为EINTR
* 可以用select和poll实现微秒级的定时器
* select可同时监控fd的可读、可写、有异常待处理，且能够在超时微秒级后返回。
* ![Select返回某个套接字就绪的条件小结](./image/Select返回某个套接字就绪的条件小结.png)
* 接收低水位标记和发送低水位标记能够界定可读可写。
* ping程序是测量RRT的一个简单方法
* close终止读和写两个方向的数据传送。也就是说调用close后该套接字既不能read，也不能write。这就导致了在回显程序中，客户端读入一个EOF后close socket，给客户端发送了FIN，之后客户端就不能读取任何从服务端发送来的数据了，就造成了回显数据的不完整，可用shutdown来对这个问题进行解决。
* 拒绝服务攻击：针对服务器做些动作，导致服务器被挂起，进而不能再为其他合法客户提供服务
* poll提供的功能与select类似，不过在处理流设备时，能够提供额外的信息，这样的话能够根据反馈得到的信息灵活处理。且poll相比较与select在应用时不需要复杂的用户管理新定义的数组结构
* ![poll函数的输入events和返回revents](./image/poll函数的输入events和返回revents.png)

## 第七章 套接字选项
* getsockopt用来得到当前的套接字选项，setsockopt用来设置当前的套接字选项。
* 并非所有实现都支持所有的套接字选项
* 套接字选项可以设置诸如接收缓冲区大小、发送缓冲区大小、接受缓冲区低水位标记、发送缓冲区低水位标记、接受超时、发送超时、禁止Nagle算法等选项。
	* ![如下图](./image/套接字层和IP层的套接字选项汇总.png)
	* ![如下图](./image/传输层的套接字选项汇总.png)
* SO_KEEPALIVE套接字选项能够隔一段时间自动在应用层无法感知的情况下给对端发送一个保持存活探测分节
* SO_LINGER套接字选项
	* 本选项指定close函数对面向连接的协议如何操作
	* ![检测各种TCP条件的方法](./image/检测各种TCP条件的方法.png)
	* 默认操作是close立即返回，但是如果有数据残留在套接字发送缓冲区中，系统将试着把这些数据发送给对端.SO_LINGR套接字使得我们可以改变这个默认设置。setsockopt传递一特定的结构，如果l_onoff为0，则保持close的默认设置,
		* 如图![close的默认操作](./image/close的默认操作.png)
	* setsockopt，如果l_onoff为非0值且l_linger为0，那么当close某个连接时TCP将终止该链接。也就是说TCP将丢弃保留在套接字发送缓冲区中的任何数据，并发送一个RST给对端，而没有通常的四分组连接终止序列（四次挥手）。
	* setsockopt，如果l_onoff非零且l_linger也非0，那么当套接字close时内核将拖延一段时间，这就是说如果在套接字发送缓冲区中仍残留有数据，那么进程将阻塞在close中，直到所有数据都已发送完毕且均被对方确认或延滞时间到（见下两图）。如果在数据发送完并被确认前延滞时间到的话，close将返回EWOULDBLOCK错误，且套接字发送缓冲区中的任何残留数据都被丢弃。
		* ![如图](./image/图7-8.png)
		* ![如图](./image/图7-9.png)
		* 由此可见，l_linger字段设置的是延滞时间，若在该时间内没有收到FIN的ack，那么close将直接返回并发送RST
	* ![各情况总结](./image/shutdown和SOLINGER各种情况的总结.png)
		* 这个图很有用，总结了shutdown和close的所有情况。
* SO_RCVBUF和SO_SNDBUF套接字选项
	* 每个套接字都有一个发送缓冲区和接收缓冲区
	* TCP套接字的接收缓冲区不可能溢出，因为有流量控制控制对端发送的数据，如果对端无视窗口大小而发送了超过该窗口大小的数据，本端TCP将丢弃他们。
	* 设置缓冲区大小时，函数调用的顺序很重要，这是因为：1.TCP的窗口规模选项是在建立连接时用SYN分节与对端互换得到的。2.**套接字缓冲区的大小总是由新创建的已连接套接字从监听套接字继承而来**。因此，对于客户，应在connect前设置本套接字选项，对于服务器，应在listen前给监听套接字设置缓冲区大小。
	* TCP套接字缓冲区的大小至少应该是相应连接的MSS值的四倍。MSS值为512B或1460B，相应的，典型缓冲区大小默认值是8192B或更大。
	* 在实际应用中对缓存区大小的设置跟带宽-延迟积（表征全双工管道的容量）有关。该指标越大，为了充分提高效率，设置的缓存区大小也应该更大。因为如果缓冲区大小小于该值，那么管道将由于TCP的流量控制不会处于满状态，性能也低于期望值。
* SO_RCVLOWAT和SO_SNDLOWAT套接字选项设置接收低水位标记和发送低水位标记，供给select函数使用。标记可读可写标志在缓冲区的临界值
* SO_RCVTIMEO和SO_SNDTIMEO套接字选项可以给套接字的接收和发送设置一个超时值。可以用秒数和微秒数来规定超时。如果I/O操作超时，将返回一个错误（读errno可知）。接收超时影响5个输入函数：read、readv、recv、recvfrom和recvmsg；发送超时影响5个输出函数：write、writev、send、sendto和sendmsg。
* fcntl函数可以设置套接字为非阻塞式I/O或者信号驱动式I/O等等
## 第14章 高级I/O函数
* 套接字设置超时的三种方法：
	* 调用alarm，超时期慢产生SIGALARM信号，需要设置信号处理函数
	* 在select中阻塞等待I/O
	* 使用SO_RCVTIMEO和SO_SNDTIMEO套接字选项（二者都不能用于为connect设置超时）
* recv和send函数，类似于标准的read和write函数，不过需要一个额外的参数，这个额外的参数可用于发送或接收带外数据、窥看外来数据（recv之后没有把对应数据从缓冲区丢弃，可用于读取排队在socket上的数据量）、等待所有数据（告知内核不要在尚未读入请求数目的字节之前让一个读操作返回，可代替readn）
* readv和writev函数，允许单个系统调用读入到或写出自一个或多个缓冲区，分散读和集中写。writev函数从缓冲区中聚集输出数据的顺序是：iov[0]、iov[1]直至iov[iovcnt-1]，writev返回输出的字节总数，通常应等于所有缓冲区长度之和；readv函数则将读入的数据按照上述同样的顺序散布到缓冲区中。readv总是先填满一个缓冲区然后再填写下一个。
* recvmsg和sendmsg函数，这两个函数是最通用的I/O函数，组合了recv和send、recvfrom和sendto、readv和writev的能力，还增加了两个新特性：给应用进程返回标志、接受或发送辅助数据。