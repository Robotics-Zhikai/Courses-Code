## version 1.0
简单的隐式线性链表实现，分数是52（util）+9（thru）= 62/100，不包括realloc
```
#define DEFAULT_TRACEFILES \
  "amptjp-bal.rep",\
  "cccp-bal.rep",\
  "cp-decl-bal.rep",\
  "expr-bal.rep",\
  "coalescing-bal.rep",\
  "random-bal.rep",\
  "random2-bal.rep",\
  "binary-bal.rep",\
  "binary2-bal.rep"
```
非空闲块时没有foot，空闲块时有foot，充分利用头的低3位数据标记前一个相邻块的空闲与否
立即合并 首次适配 




## version 2.0 
51（util）+28（thru）= 79/100（不包括realloc测试集）；

1、每一个空闲块的head包括implicithead和explicithead和foot（只包括当前块的大小）；

2、explicithead由firstaddr和secondaddr组成；

3、分配了的非空闲块的head仍然包括implicithead和explicithead，没有foot
这里边implicithead为8字节 explicithead为16字节；

4、分离表以ceil(log2(size))作为分组方式；

5、子类的头结点由firstaddr链接的单向链表链接起来，子类的头结点的secondaddr指向本子类的第一个内容结点；

6、本子类的内容结点由一个双向链表连接起来，firtaddr储存指向下一个内容节点，secondaddr指向上一个内容结点；

7、implicithead部分的除低三位部分存放本块的大小，最低一位存放本块是否是空闲块，次低位存放本块相邻的前一块是否是空闲块
倒数低三位存放本块是否是子类的头结点；

8、每次新创建的空闲块以线性时间找到子类，并在该子类以常数时间加入到对应的子类中；

9、malloc一个size后，如果首次适配的空闲块的大小大于smallestBlockSize，那么就把剩下的块加入到空闲块分离表中，
否则直接把整个空闲块都作为malloc空间；

10、free了一块空间后，会立即合并相邻的空闲块（如果存在的话）；

利用上述策略除realloc测试集都过了，但是realloc测试集由于内存耗尽的问题过不了。
因此，需要想一个优化策略。




## version 3.0
1、首先，MAX_HEAP是20*(1<<20)B,也就是说表示一个块的字节大小绝对不会超过32位（4字节）
因此implicitheadSize可以降到4B，同样的道理，footSize也可以降到4B
然后，指针也是四字节，因此explicitheadSize为2*4B；

2、然后对于非空闲块，只要有一个implicithead就够了 空闲块的话最小为implicithead+explicithead+foot（4+8+4=16B）
但是，算最小块大小的话，只能按空闲块去算，不能按非空闲块算；
但是，如果把非空闲块和空闲块的头部区分开来的话，又得写很多代码，容易出错，时间有限就不写了。经过分析，这样也不会造成利用率的明显降低

3、空闲块的头指针必须是4的倍数且不能是8的倍数，这样才能保证malloc的指针是8的倍数，
要想实现这样的结构，只需要在最开始垫一个四字节的offsetblock就行。

4、3.0实现至此，分数为52 (util) + 40 (thru) = 92/100 （不含realloc测试集）
利用率稍有增加，吞吐率大幅度增加。主要原因是之前都是把地址看成8个字节的，现在看成了四个字节，
可能在汇编级每条指令执行的CPU周期更少，进而造成大的吞吐量。
由此得到一条经验：在编程时尽量提高数据的利用率，减少数据的冗余，否则可能会降低效率

5、而且在realloc的时候，不能简单直接的分配r所指定的大小内存，而应该充分利用已有的内存大小，将已有的内存利用起来，
否则如果r的大小非常大的话，很容易就超出存储空间了.
将最后一个块如果是空闲块也利用上，那么就解决了realloc超出存储空间的问题，最终整个测试集上得到的分数是
46 (util) + 39 (thru) = 85/100(含realloc测试集)




## version 4.0（时间有限，暂未实现 有前三个版本就差不多了 之后学学malloc的源码是怎么写的 如果时间充足再写吧）
1、目前还可以想到的优化是子类的分组方式可以改一改，现在的子类分组是通过ceil(log2(size))分的，
这就造成了子类的容纳空闲块大小范围分布不均匀，进而造成某些子类的内容结点过多；
但是如果要均匀分配的话，又会造成子类头结点过多，分配时查找花销大的问题。且具体均匀分的间隔是多少没办法确定；

2、还可以的一种方法是每次新加入子类的头结点时,根据一定范围的值维护一个最大堆，堆的每个结点就是各子类的头结点，
然后每个子类的内容结点又能以该子类头结点为根又维护一个最大堆.
这样可以把空闲块插入的时间降到logn，malloc的时间降到logn，而又不改变空间利用率，增大了吞吐量；

3、再没有想到更好的方法，需要阅读malloc、realloc的源码才能知道。今后填坑
